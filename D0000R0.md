---
title: "Array assignment and initialization"
document: D0000R0
date: 2019-11-16
audience: Evolution Working Group
author:
 - name: Krystian Stasiowski
   email: <sdkrystian@gmail.com>
 - name: Theodoric Stier
   email: <kerdek7@gmail.com>
toc: false
monofont: "DejaVu Sans Mono"
---

# Wording

All wording is relative to [N4835](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4835.pdf).

## Allow array assignment

Changes to [expr.ass] p2

> [2]{.pnum} In simple assignment [(=)]{.rm}[of the form `E1 = E2`, when the left operand is not of array type,]{.add} the object referred to by the left operand is modified by replacing its value with the result of the right operand. [If the left operand is of type "array of `N T`", the right operand shall be of the same type (ignoring cv-qualification) and the effect is identical to performing `E1[i] = E2[i]` for each `0 ≤ i < N`.]{.add}

## Allow array initialization

Changes to [dcl.init] p17 sub 5

:::add
> [17.5]{.pnum} Otherwise, if the destination type is an array:

> -    [17.5.1]{.pnum} If the initializer expression is of array type and the cv-unqualified versions of the source and destination type differ, the program is ill-formed. Then, if the initializer expression is a prvalue, the initializer expression is used to initialize the destination object.
:::

> -    [17.5.2]{.pnum} Otherwise, if the destination type is an array, the object is initialized as follows. Let `x₁, …, xₖ` be the elements of the *expression-list* [or array denoted by the initializer expression if the source type is "array of `k T`"]{.add}. If the destination type is an array of unknown bound, it is defined as having `k` elements. [...]

## Allow returning arrays

Changes to [dcl.fct] p11

> [11]{.pnum} Functions shall not have a return type of [function]{.add} type [array or function]{.rm}, although they may have a return type of type pointer or reference to [such things]{.rm}[function]{.add}. There shall be no arrays of functions, although there can be arrays of pointers to functions.

## Deducing arrays  with `auto`

Changes to [dcl.array] p4

> [4]{.pnum} `U` is called the array *element type*; this type shall not be [a placeholder type,]{.rm} a reference type, a function type, an array of unknown bound, or `cv void`.

\pagebreak

Changes to [dcl.type.auto.deduc] p4

> [4]{.pnum} [...] Deduce a value for `U` using the rules of template argument deduction from a function call, where `P` is a function template parameter type and the corresponding argument is `e`[, except that if `P` is an array type, `P&` is used in place of `P` in the synthesized function template]{.add}. If the deduction fails, the declaration is ill-formed. Otherwise, `T′` is obtained by substituting the deduced `U` into `P`. 

Changes to [dcl.array] p7

> [7]{.pnum} [...] In these cases, the array bound is calculated from the number of [initial]{.rm} elements [in the initializer list or the bound of the type of the initializer expression `N`]{.add}[(say, `N`) supplied, and]{.rm}[;]{.add} the type of the array is “array of `N U`”.

## Copy elision for arrays

Changes to [class.copy.elision] p1

> [1]{.pnum} When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class [object or array of class]{.add} object[s]{.add}, even if the constructor selected for the copy/move operation[(s)]{.add} and/or the destructor for the object [or its elements]{.add} have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation[(s)]{.add} as simply two different ways of referring to the same object. If the first parameter of the selected constructor is an rvalue reference to the object's type [(or, in the case of an array, its element type)]{.add}, the destruction of that object occurs when the target would have been destroyed; otherwise, the destruction occurs at the later of the times when the two objects would have been destroyed without the optimization. [...]

> -    [1.1]{.pnum} in a `return` statement in a function with a class [or array]{.add} return type [...] the copy/move operation[(s)]{.add} can be omitted by constructing the automatic object [or array elements]{.add} directly into the function call's return object

## Wording Cleanup

Changes to [temp.deduct] p11 sub 10

> [11.10]{.pnum} Attempting to create a function type in which a parameter has a type of `void`, or in which the return type is a function type [or array type]{.rm}.

