---
title: "Array assignment and initialization"
document: D0000R0
date: 2019-11-16
audience: Evolution Working Group
author:
 - name: Krystian Stasiowski
   email: <sdkrystian@gmail.com>
 - name: Theodoric Stier
   email: <kerdek7@gmail.com>
toc: false
monofont: "DejaVu Sans Mono"
---

# Abstract

We propose initialization, assignment, and placeholder semantics for array types to bring consistency to the semantics of aggregates.

# Motivation

Aggregates were created with the purpose of providing semantics and behavior which are reasonable to expect from such types, but aggregate classes enjoy most the provisions while arrays appear to possess some artificial and confusing limitations. It is possible to enjoy the semantics and behaviors of aggregate classes while using an array by wrapping it or using `std::array`. Wrapping data in a type with a descriptive name is often good practice, but some arrays are self-explanatory, and such wrapping only represents an unnecessary cognitive burden in such cases.

<table>
<tr>
<td  valign="top">
<pre lang="cpp">

int samples_x[5];
int samples_y[5] = samples_x;
// Ill-Formed, but self-explanatory

</pre>
</td>
<td  valign="top">
<pre lang="cpp">

struct samples { int s[5]; };
samples x;
samples y = x; // OK, but why?

</pre>
</td>
</tr>
</table>

It should not make sense to a beginner why arrays are element-wise copy/move constructible/assignable when they are data members but not when they are named by local variables. To an expert, this limitation may appear artificial, perhaps even backwards. Arrays could be readily understood as like aggregate classes except having elements which are referred to by subscripts instead of names and no member functions, base classes, or operator overloads.

Array return types are legible in trailing return type syntax.

```cpp
auto make_coefs() -> int[3]
```

An aggregate class whose first element is an array with bound *n* must have *n* initializers before any later element may be initialized.

```cpp
struct lp_3_point
{
    int coords[3];
    float power;
};

auto make_lp_3_point(int (&c)[3]) -> lp_3_point
{
    // Must write four elements in order to initialize power
    return { c[0], c[1], c[2], 1.0f };
    // Would make sense to initialize an array with an array
    return { c, 1.0f };
}
```

If the user provides an assignment operator to a class having an array data member, they must explicitly iterate over the elements to be assigned, or wrap the array as above.

```cpp
class widget
{
    gadget g[4]; // user-provided assignment is now painful
};
```

# Proposal

We propose to define initialization of an array type by a like array type as element-wise and sequenced, to define array return types, and to define reasonable type deduction for array placeholder types. Such initialization and assignment could simplify the implementation of container types such as `std::vector`, which reduces the likelihood of programming errors.

We believe that providing this similarity by defining initialization and assignment from an array does not sacrifice any backward compatibility with the C language. None of the related syntax is valid in any C or C++ program. Some C++ programs may have their meaning changed. For example, the value defined by `std::is_assignable` will change for some specializations.

# Wording

All wording is relative to [N4835](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4835.pdf).

## Allow array assignment

Changes to [expr.ass] p2

> [2]{.pnum} In simple assignment [(=)]{.rm}[of the form `E1 = E2`, when the left operand is not of array type,]{.add} the object referred to by the left operand is modified by replacing its value with the result of the right operand. [If the left operand is of type "array of `N T`", the right operand shall be of the same type (ignoring cv-qualification) and the effect is identical to performing `E1[i] = E2[i]` for each `0 ≤ i < N`.]{.add}

## Allow array initialization

Changes to [dcl.init] p17 sub 5

:::add
> [17.5]{.pnum} Otherwise, if the destination type is an array:

> -    [17.5.1]{.pnum} If the initializer expression is of array type and the cv-unqualified versions of the element types of the source and destination type differ, the program is ill-formed. Then, if the initializer expression is a prvalue, the initializer expression is used to initialize the destination object.
:::

> -    [17.5.2]{.pnum} Otherwise, if the destination type is an array, the object is initialized as follows. Let `x₁, …, xₖ` be the elements of the *expression-list* [or array denoted by the initializer expression if the source type is "array of `k T`"]{.add}. If the destination type is an array of unknown bound, it is defined as having `k` elements. [...]

Changes to [dcl.init.list] p3 sub 2

> [3.2]{.pnum} If `T` is an aggregate [class]{.rm} and the initializer list has a single element of type `cv U`, where `U` is `T`[,]{.add} or[, if `T` is a class type,]{.add} a class derived from `T`, the object is initialized [...]

## Allow returning arrays

Changes to [dcl.fct] p11

> [11]{.pnum} Functions shall not have a return type of [function]{.add} type [array or function]{.rm}, although they may have a return type of type pointer or reference to [such things]{.rm}[function]{.add}. There shall be no arrays of functions, although there can be arrays of pointers to functions.

## Deducing arrays  with `auto`

Changes to [dcl.array] p4

> [4]{.pnum} `U` is called the array *element type*; this type shall not be [a placeholder type,]{.rm} a reference type, a function type, an array of unknown bound, or `cv void`.

Changes to [dcl.type.auto.deduc] p4

> [4]{.pnum} [...] Deduce a value for `U` using the rules of template argument deduction from a function call, where `P` is a function template parameter type and the corresponding argument is `e`[, except that if `P` is an array type, `P&` is used in place of `P` in the synthesized function template]{.add}. If the deduction fails, the declaration is ill-formed. Otherwise, `T′` is obtained by substituting the deduced `U` into `P`. 

Changes to [dcl.array] p7

> [7]{.pnum} [...] In these cases, the array bound is calculated from the number of [initial]{.rm} elements [in the initializer list or the bound of the type of the initializer expression `N`]{.add}[(say, `N`) supplied, and]{.rm}[;]{.add} the type of the array is “array of `N U`”.

## Copy elision for arrays

Changes to [class.copy.elision] p1

> [1]{.pnum} When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class [object or array of class]{.add} object[s]{.add}, even if the constructor selected for the copy/move operation[(s)]{.add} and/or the destructor for the object [or its elements]{.add} have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation[(s)]{.add} as simply two different ways of referring to the same object. If the first parameter of the selected constructor is an rvalue reference to the object's type [(or, in the case of an array, its element type)]{.add}, the destruction of that object occurs when the target would have been destroyed; otherwise, the destruction occurs at the later of the times when the two objects would have been destroyed without the optimization. [...]

> -    [1.1]{.pnum} in a `return` statement in a function with a class [or array]{.add} return type [...] the copy/move operation[(s)]{.add} can be omitted by constructing the automatic object [or array elements]{.add} directly into the function call's return object

## Wording Cleanup

Changes to [temp.deduct] p11 sub 10

> [11.10]{.pnum} Attempting to create a function type in which a parameter has a type of `void`, or in which the return type is a function type [or array type]{.rm}.

